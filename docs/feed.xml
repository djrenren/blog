<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-07-25T17:13:43-07:00</updated><id>http://localhost:4000/</id><title type="html">Your awesome title</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">#[test] in 2018</title><link href="http://localhost:4000/rust/testing/2018/07/19/test-in-2018.html" rel="alternate" type="text/html" title="#[test] in 2018" /><published>2018-07-19T16:11:01-07:00</published><updated>2018-07-19T16:11:01-07:00</updated><id>http://localhost:4000/rust/testing/2018/07/19/test-in-2018</id><content type="html" xml:base="http://localhost:4000/rust/testing/2018/07/19/test-in-2018.html">&lt;p&gt;Lately, I’ve been working implementing the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2318-custom-test-frameworks.md&quot;&gt;Custom Test Frameworks eRFC&lt;/a&gt; for Rust.
While exploring the compiler codebase, I’ve learned about the internals of testing in Rust
and figured it would be interesting to share.&lt;/p&gt;

&lt;h3 id=&quot;the-test-attribute&quot;&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;#[test]&lt;/code&gt; attribute&lt;/h3&gt;
&lt;p&gt;Today, rust programmers rely on a built in attribute called &lt;code class=&quot;highlighter-rouge&quot;&gt;#[test]&lt;/code&gt;.
All you have to do is mark a function as a test and include some asserts like so:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;#[test]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;my_test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When this program is compiled using &lt;code class=&quot;highlighter-rouge&quot;&gt;rustc --test&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;cargo test&lt;/code&gt;, it will
produce an executable that can run this, and any other test function. This
method of testing allows tests to live alongside code in an organic way. You
can even put tests inside private modules:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_priv_mod&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;my_priv_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;#[test]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_priv_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;my_priv_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Private items can thus be easily tested without worrying about how to expose
the them to any sort of external testing apparatus. This is key to the
ergonomics of testing in Rust. Semantically, however, it’s rather odd.
How does any sort of &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; function invoke these tests if they’re not visible?
What exactly is &lt;code class=&quot;highlighter-rouge&quot;&gt;rustc --test&lt;/code&gt; doing?&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#[test]&lt;/code&gt; is implemented as a syntactic transformation inside the compiler’s
&lt;a href=&quot;https://github.com/rust-lang/rust/tree/master/src/libsyntax&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;libsyntax&lt;/code&gt; crate&lt;/a&gt;. Essentially, it’s a fancy macro, that
rewrites the crate in 3 steps:&lt;/p&gt;

&lt;h4 id=&quot;step-1-re-exporting&quot;&gt;Step 1: Re-Exporting&lt;/h4&gt;

&lt;p&gt;As mentioned earlier, tests can exist inside private modules, so we need a way of
exposing them to the main function, without breaking any existing code. To that end,
&lt;code class=&quot;highlighter-rouge&quot;&gt;libsyntax&lt;/code&gt; will create local modules called &lt;code class=&quot;highlighter-rouge&quot;&gt;__test_reexports&lt;/code&gt; that recursively reexport tests.
This expansion translates the above example into:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_priv_mod&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;my_priv_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_priv_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;my_priv_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__test_reexports&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test_priv_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, our test can be accessed as:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;my_priv_mod::__test_reexports::test_priv_func&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For deeper module
structures, &lt;code class=&quot;highlighter-rouge&quot;&gt;__test_reexports&lt;/code&gt; will reexport modules that contain tests, so a
test at &lt;code class=&quot;highlighter-rouge&quot;&gt;a::b::my_test&lt;/code&gt; becomes:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a::__test_reexports::b::__test_reexports::my_test&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;While this process seems
pretty safe, what happens if there is an existing &lt;code class=&quot;highlighter-rouge&quot;&gt;__test_reexports&lt;/code&gt; module?
The answer: nothing.&lt;/p&gt;

&lt;p&gt;To explain, we need to understand &lt;a href=&quot;https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.Ident.html&quot;&gt;how the AST represents
identifiers&lt;/a&gt;. The name of every function, variable, module, etc. is
not stored as a string, but rather as an opaque &lt;a href=&quot;https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.Ident.html&quot;&gt;Symbol&lt;/a&gt; which is
essentially an ID number for each identifier. The compiler keeps a separate
hashtable that allows us to recover the human-readable name of a Symbol when
necessary (such as when printing a syntax error). When the compiler generates
the &lt;code class=&quot;highlighter-rouge&quot;&gt;__test_reexports&lt;/code&gt; module, it generates a new Symbol for the identifier,
so while the compiler-generated &lt;code class=&quot;highlighter-rouge&quot;&gt;__test_reexports&lt;/code&gt; may share a name with your
hand-written one, it will not share a Symbol. This technique prevents name
collision during code generation and is the foundation of Rust’s macro
hygiene.&lt;/p&gt;

&lt;h4 id=&quot;step-2-harness-generation&quot;&gt;Step 2: Harness Generation&lt;/h4&gt;
&lt;p&gt;Now that our tests are accessible from the root of our crate, we need to do something with them.
&lt;code class=&quot;highlighter-rouge&quot;&gt;libsyntax&lt;/code&gt; generates a module like so:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__test&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;crate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TESTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'static&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestDescAndFn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*...*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;#[main]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;test_static_main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TESTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;While this transformation is simple, it gives us a lot of insight into how tests are actually run.
The tests are aggregated into an array and passed to a test runner called &lt;code class=&quot;highlighter-rouge&quot;&gt;test_static_main&lt;/code&gt;.
We’ll come back to exactly what &lt;code class=&quot;highlighter-rouge&quot;&gt;TestDescAndFn&lt;/code&gt; is, but for now, the key takeaway is that there is a crate
called &lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt;&lt;/a&gt; that is part of Rust core, that implements all of the runtime for testing. &lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt;’s interface is unstable,
so the only stable way to interact with it is through the &lt;code class=&quot;highlighter-rouge&quot;&gt;#[test]&lt;/code&gt; macro.&lt;/p&gt;

&lt;h4 id=&quot;step-3-test-object-generation&quot;&gt;Step 3: Test Object Generation&lt;/h4&gt;
&lt;p&gt;If you’ve written tests in Rust before, you may be familiar with some of the optional attributes available on test functions.
For example, a test can be annotated with &lt;code class=&quot;highlighter-rouge&quot;&gt;#[should_panic]&lt;/code&gt; if we expect the test to cause a panic. It looks something like this:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;#[test]&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;#[should_panic]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;panic!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;intentional&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This means our tests are more than just simple functions, they have configuration information as well. &lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt; encodes this configuration
data into a struct called &lt;a href=&quot;https://doc.rust-lang.org/test/struct.TestDesc.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TestDesc&lt;/code&gt;&lt;/a&gt;. For each test function in a crate, &lt;code class=&quot;highlighter-rouge&quot;&gt;libsyntax&lt;/code&gt; will parse its attributes and generate a &lt;code class=&quot;highlighter-rouge&quot;&gt;TestDesc&lt;/code&gt; instance.
It then combines the &lt;code class=&quot;highlighter-rouge&quot;&gt;TestDesc&lt;/code&gt; and test function into the predictably named &lt;code class=&quot;highlighter-rouge&quot;&gt;TestDescAndFn&lt;/code&gt; struct, that &lt;code class=&quot;highlighter-rouge&quot;&gt;test_static_main&lt;/code&gt; operates on.
For a given test, the generated &lt;code class=&quot;highlighter-rouge&quot;&gt;TestDescAndFn&lt;/code&gt; instance looks like so:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestDescAndFn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;desc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestDesc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;StaticTestName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ignore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;should_panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;ShouldPanic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Yes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;allow_fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;testfn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;StaticTestFn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(||&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;assert_test_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;crate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;__test_reexports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once we’ve constructed an array of these test objects, they’re passed to the
test runner via the harness generated in step 2. While this step could be
considered part of Step 2, I want to draw attention to it as a separate
concept, because it will be key to the implementation of custom test
frameworks, but that’ll be another blog post.&lt;/p&gt;

&lt;h3 id=&quot;afterword-investigative-techniques&quot;&gt;Afterword: Investigative Techniques&lt;/h3&gt;
&lt;p&gt;While I learned a lot of this information from the compiler source directly, I’ve since learned there’s a very simple way to see what the compiler is doing.
On nightly rust, there’s an unstable flag called &lt;code class=&quot;highlighter-rouge&quot;&gt;unpretty&lt;/code&gt; that you can use to print out the module source after macro expansion:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rustc my_mod.rs &lt;span class=&quot;nt&quot;&gt;-Z&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;unpretty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That’s all for now folks, if you have any thoughts or questions feel free to find me on &lt;a href=&quot;https://wiki.mozilla.org/IRC&quot;&gt;IRC&lt;/a&gt;, &lt;a href=&quot;https://discordapp.com/invite/aVESxV8&quot;&gt;Discord&lt;/a&gt;, under the username &lt;code class=&quot;highlighter-rouge&quot;&gt;djrenren&lt;/code&gt;, or on twitter as &lt;a href=&quot;https://twitter.com/thedjrenren&quot;&gt;@thedjrenren&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Lately, I’ve been working implementing the Custom Test Frameworks eRFC for Rust. While exploring the compiler codebase, I’ve learned about the internals of testing in Rust and figured it would be interesting to share.</summary></entry></feed>