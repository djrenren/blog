<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2018-08-02T13:57:25-07:00</updated><id>/</id><title type="html">Your awesome title</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Baby Steps: Fixing Test Scoping</title><link href="/rust/testing/2018/08/01/expansion.html" rel="alternate" type="text/html" title="Baby Steps: Fixing Test Scoping" /><published>2018-08-01T04:00:00-07:00</published><updated>2018-08-01T04:00:00-07:00</updated><id>/rust/testing/2018/08/01/expansion</id><content type="html" xml:base="/rust/testing/2018/08/01/expansion.html">&lt;p&gt;I recently set out to fix &lt;a href=&quot;https://github.com/rust-lang/rust/issues/52557&quot;&gt;a bug&lt;/a&gt; in &lt;a href=&quot;/rust/testing/2018/07/19/test-in-2018.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#[test]&lt;/code&gt; expansion in
Rust&lt;/a&gt;. What follows is a chronicle of that journey.&lt;/p&gt;

&lt;h2 id=&quot;the-bug&quot;&gt;The Bug&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;rustc&lt;/code&gt; encounters a &lt;code class=&quot;highlighter-rouge&quot;&gt;#[test]&lt;/code&gt; attribute it will do one of two things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt; mode, the annotated item is removed&lt;/li&gt;
  &lt;li&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt; mode, the item is made public so it can be called by the test runner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is typically safe because direct references to &lt;code class=&quot;highlighter-rouge&quot;&gt;#[test]&lt;/code&gt;
will cause errors in any mode where the function is removed.&lt;/p&gt;

&lt;p&gt;Enter glob imports. Statements like &lt;code class=&quot;highlighter-rouge&quot;&gt;use my_mod::*&lt;/code&gt; allow us to import an
entire namespace into another without naming the specific items. We now have
the requisite pieces to construct the bug:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;#[test]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;caller&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;assert_eq!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When compiled normally, &lt;code class=&quot;highlighter-rouge&quot;&gt;use B::*&lt;/code&gt; does nothing and the assert inside &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; will
always pass. When compiled for test, however, &lt;code class=&quot;highlighter-rouge&quot;&gt;B::foo&lt;/code&gt; will be marked as public,
which will cause &lt;code class=&quot;highlighter-rouge&quot;&gt;use B::*&lt;/code&gt; to &lt;a href=&quot;https://doc.rust-lang.org/rust-by-example/variable_bindings/scope.html&quot;&gt;shadow&lt;/a&gt; the &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; we got from &lt;code class=&quot;highlighter-rouge&quot;&gt;A::foo&lt;/code&gt;.
Our assert now fails saying that 6 does not equal 0. This means &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; behaves
differently in test builds which is undesirable. Worse still, it happens due to
an implementation detail in the compiler that authors should never worry about.&lt;/p&gt;

&lt;h2 id=&quot;the-fix&quot;&gt;The Fix&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;The Constraint:&lt;/strong&gt;
Test functions must be made public but they must also not pollute other namespaces.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Solution:&lt;/strong&gt;
Give test functions a name that can never exist in user code.&lt;/p&gt;

&lt;p&gt;Rust has an internal mechanism called &lt;code class=&quot;highlighter-rouge&quot;&gt;gensym&lt;/code&gt; that allows the creation of
guaranteed unique names. If we rename test functions with a gensym’d name,
then it’s okay for them to pollute namespaces because it’s impossible to
reference them.&lt;/p&gt;

&lt;p&gt;Just renaming isn’t enough though, because rust currently allows one test
to call another. While I think this is a terrible thing to allow, we do and
so must continue to allow it. We then need to add the old name back into the
namespace. Just add a &lt;code class=&quot;highlighter-rouge&quot;&gt;use [gensymed] as foo&lt;/code&gt; to add foo back to our namespace.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Nitty Gritty:&lt;/strong&gt;
While the theory behind this fix is sound, simply implementing it didn’t work
the way I’d expected. I first attempted to implement the change inside
&lt;a href=&quot;https://github.com/rust-lang/rust/tree/master/src/libsyntax&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;libsyntax&lt;/code&gt;&lt;/a&gt;’s &lt;code class=&quot;highlighter-rouge&quot;&gt;TestHarnessGenerator&lt;/code&gt;, but this resulted in
strange errors about not being able to find imports despite the AST and HIR
being correct. While it seems obvious now, it took me a week to figure out
this was because harness generation runs midway through name resolution.&lt;/p&gt;

&lt;p&gt;As a reminder, name resolution is the process by which the compiler realizes
that the variable &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; at one location, is talking about the same variable as
an &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; somewhere else in the code.&lt;/p&gt;

&lt;p&gt;A good chunk of name resolution occurs during macro expansion in
&lt;a href=&quot;https://github.com/rust-lang/rust/blob/8eb4941e30d2a40bc03840dd0d99beb5aaf8159d/src/libsyntax/ext/expand.rs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;libsyntax/ext/expand.rs&lt;/code&gt;&lt;/a&gt;. In fact, this was already where tests
were being made &lt;code class=&quot;highlighter-rouge&quot;&gt;pub&lt;/code&gt;. What I had originally discounted as a design mistake,
was actually crucial to correct operation. With a quick reimplementation
everything worked great. I realized I’d forgotten to account for the unused
variable lints, but that was a quick fix.&lt;/p&gt;

&lt;p&gt;You can see the result in &lt;a href=&quot;https://github.com/rust-lang/rust/pull/52890&quot;&gt;this pull request&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;afterword-why-write-about-this&quot;&gt;Afterword: Why Write About This&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Honestly, very few people will get much out of this post, but being
lost in a complex open-source project can be disheartening at the very
least. By discussing these esoteric bits, I hope I can help someone who gets stuck
in similar bits of code in the future, or maybe just assure them that it’s common
to feel lost. As always, feel free to reach out if you have questions.&lt;/p&gt;</content><author><name></name></author><summary type="html">I recently set out to fix a bug in #[test] expansion in Rust. What follows is a chronicle of that journey.</summary></entry><entry><title type="html">#[test] in 2018</title><link href="/rust/testing/2018/07/19/test-in-2018.html" rel="alternate" type="text/html" title="#[test] in 2018" /><published>2018-07-19T16:11:01-07:00</published><updated>2018-07-19T16:11:01-07:00</updated><id>/rust/testing/2018/07/19/test-in-2018</id><content type="html" xml:base="/rust/testing/2018/07/19/test-in-2018.html">&lt;p&gt;Lately, I’ve been working implementing the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2318-custom-test-frameworks.md&quot;&gt;Custom Test Frameworks eRFC&lt;/a&gt; for Rust.
While exploring the compiler codebase, I’ve learned about the internals of testing in Rust
and figured it would be interesting to share.&lt;/p&gt;

&lt;h3 id=&quot;the-test-attribute&quot;&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;#[test]&lt;/code&gt; attribute&lt;/h3&gt;
&lt;p&gt;Today, rust programmers rely on a built in attribute called &lt;code class=&quot;highlighter-rouge&quot;&gt;#[test]&lt;/code&gt;.
All you have to do is mark a function as a test and include some asserts like so:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;#[test]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;my_test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When this program is compiled using &lt;code class=&quot;highlighter-rouge&quot;&gt;rustc --test&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;cargo test&lt;/code&gt;, it will
produce an executable that can run this, and any other test function. This
method of testing allows tests to live alongside code in an organic way. You
can even put tests inside private modules:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_priv_mod&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;my_priv_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;#[test]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_priv_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;my_priv_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Private items can thus be easily tested without worrying about how to expose
the them to any sort of external testing apparatus. This is key to the
ergonomics of testing in Rust. Semantically, however, it’s rather odd.
How does any sort of &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; function invoke these tests if they’re not visible?
What exactly is &lt;code class=&quot;highlighter-rouge&quot;&gt;rustc --test&lt;/code&gt; doing?&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#[test]&lt;/code&gt; is implemented as a syntactic transformation inside the compiler’s
&lt;a href=&quot;https://github.com/rust-lang/rust/tree/master/src/libsyntax&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;libsyntax&lt;/code&gt; crate&lt;/a&gt;. Essentially, it’s a fancy macro, that
rewrites the crate in 3 steps:&lt;/p&gt;

&lt;h4 id=&quot;step-1-re-exporting&quot;&gt;Step 1: Re-Exporting&lt;/h4&gt;

&lt;p&gt;As mentioned earlier, tests can exist inside private modules, so we need a way of
exposing them to the main function, without breaking any existing code. To that end,
&lt;code class=&quot;highlighter-rouge&quot;&gt;libsyntax&lt;/code&gt; will create local modules called &lt;code class=&quot;highlighter-rouge&quot;&gt;__test_reexports&lt;/code&gt; that recursively reexport tests.
This expansion translates the above example into:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_priv_mod&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;my_priv_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_priv_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;my_priv_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__test_reexports&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test_priv_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, our test can be accessed as:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;my_priv_mod::__test_reexports::test_priv_func&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For deeper module
structures, &lt;code class=&quot;highlighter-rouge&quot;&gt;__test_reexports&lt;/code&gt; will reexport modules that contain tests, so a
test at &lt;code class=&quot;highlighter-rouge&quot;&gt;a::b::my_test&lt;/code&gt; becomes:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a::__test_reexports::b::__test_reexports::my_test&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;While this process seems
pretty safe, what happens if there is an existing &lt;code class=&quot;highlighter-rouge&quot;&gt;__test_reexports&lt;/code&gt; module?
The answer: nothing.&lt;/p&gt;

&lt;p&gt;To explain, we need to understand &lt;a href=&quot;https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.Ident.html&quot;&gt;how the AST represents
identifiers&lt;/a&gt;. The name of every function, variable, module, etc. is
not stored as a string, but rather as an opaque &lt;a href=&quot;https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.Ident.html&quot;&gt;Symbol&lt;/a&gt; which is
essentially an ID number for each identifier. The compiler keeps a separate
hashtable that allows us to recover the human-readable name of a Symbol when
necessary (such as when printing a syntax error). When the compiler generates
the &lt;code class=&quot;highlighter-rouge&quot;&gt;__test_reexports&lt;/code&gt; module, it generates a new Symbol for the identifier,
so while the compiler-generated &lt;code class=&quot;highlighter-rouge&quot;&gt;__test_reexports&lt;/code&gt; may share a name with your
hand-written one, it will not share a Symbol. This technique prevents name
collision during code generation and is the foundation of Rust’s macro
hygiene.&lt;/p&gt;

&lt;h4 id=&quot;step-2-harness-generation&quot;&gt;Step 2: Harness Generation&lt;/h4&gt;
&lt;p&gt;Now that our tests are accessible from the root of our crate, we need to do something with them.
&lt;code class=&quot;highlighter-rouge&quot;&gt;libsyntax&lt;/code&gt; generates a module like so:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__test&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;crate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TESTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'static&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestDescAndFn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*...*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;#[main]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;test_static_main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TESTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;While this transformation is simple, it gives us a lot of insight into how tests are actually run.
The tests are aggregated into an array and passed to a test runner called &lt;code class=&quot;highlighter-rouge&quot;&gt;test_static_main&lt;/code&gt;.
We’ll come back to exactly what &lt;code class=&quot;highlighter-rouge&quot;&gt;TestDescAndFn&lt;/code&gt; is, but for now, the key takeaway is that there is a crate
called &lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt;&lt;/a&gt; that is part of Rust core, that implements all of the runtime for testing. &lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt;’s interface is unstable,
so the only stable way to interact with it is through the &lt;code class=&quot;highlighter-rouge&quot;&gt;#[test]&lt;/code&gt; macro.&lt;/p&gt;

&lt;h4 id=&quot;step-3-test-object-generation&quot;&gt;Step 3: Test Object Generation&lt;/h4&gt;
&lt;p&gt;If you’ve written tests in Rust before, you may be familiar with some of the optional attributes available on test functions.
For example, a test can be annotated with &lt;code class=&quot;highlighter-rouge&quot;&gt;#[should_panic]&lt;/code&gt; if we expect the test to cause a panic. It looks something like this:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;#[test]&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;#[should_panic]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;panic!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;intentional&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This means our tests are more than just simple functions, they have configuration information as well. &lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt; encodes this configuration
data into a struct called &lt;a href=&quot;https://doc.rust-lang.org/test/struct.TestDesc.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TestDesc&lt;/code&gt;&lt;/a&gt;. For each test function in a crate, &lt;code class=&quot;highlighter-rouge&quot;&gt;libsyntax&lt;/code&gt; will parse its attributes and generate a &lt;code class=&quot;highlighter-rouge&quot;&gt;TestDesc&lt;/code&gt; instance.
It then combines the &lt;code class=&quot;highlighter-rouge&quot;&gt;TestDesc&lt;/code&gt; and test function into the predictably named &lt;code class=&quot;highlighter-rouge&quot;&gt;TestDescAndFn&lt;/code&gt; struct, that &lt;code class=&quot;highlighter-rouge&quot;&gt;test_static_main&lt;/code&gt; operates on.
For a given test, the generated &lt;code class=&quot;highlighter-rouge&quot;&gt;TestDescAndFn&lt;/code&gt; instance looks like so:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestDescAndFn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;desc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestDesc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;StaticTestName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ignore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;should_panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;ShouldPanic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Yes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;allow_fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;testfn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;StaticTestFn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(||&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;assert_test_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;crate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;__test_reexports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once we’ve constructed an array of these test objects, they’re passed to the
test runner via the harness generated in step 2. While this step could be
considered part of Step 2, I want to draw attention to it as a separate
concept, because it will be key to the implementation of custom test
frameworks, but that’ll be another blog post.&lt;/p&gt;

&lt;h3 id=&quot;afterword-investigative-techniques&quot;&gt;Afterword: Investigative Techniques&lt;/h3&gt;
&lt;p&gt;While I learned a lot of this information from the compiler source directly, I’ve since learned there’s a very simple way to see what the compiler is doing.
On nightly rust, there’s an unstable flag called &lt;code class=&quot;highlighter-rouge&quot;&gt;unpretty&lt;/code&gt; that you can use to print out the module source after macro expansion:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rustc my_mod.rs &lt;span class=&quot;nt&quot;&gt;-Z&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;unpretty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That’s all for now folks, if you have any thoughts or questions feel free to find me on &lt;a href=&quot;https://wiki.mozilla.org/IRC&quot;&gt;IRC&lt;/a&gt;, &lt;a href=&quot;https://discordapp.com/invite/aVESxV8&quot;&gt;Discord&lt;/a&gt;, under the username &lt;code class=&quot;highlighter-rouge&quot;&gt;djrenren&lt;/code&gt;, or on twitter as &lt;a href=&quot;https://twitter.com/thedjrenren&quot;&gt;@thedjrenren&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Lately, I’ve been working implementing the Custom Test Frameworks eRFC for Rust. While exploring the compiler codebase, I’ve learned about the internals of testing in Rust and figured it would be interesting to share.</summary></entry></feed>